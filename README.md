## Порівняння жадібного алгоритму та алгоритму динамічного програмування для задачі про монети

### Жадібний алгоритм
Жадібний алгоритм обирає найбільший номінал, який не перевищує залишок суми, поки не буде досягнуто цільову суму.

- **Часова складність**: \(O(n)\), де \(n\) — кількість номіналів. Часова складність не залежить від величини цільової суми.
- **Продуктивність при великих сумах**: Жадібний алгоритм працює швидко, але може не давати оптимального рішення для нестандартних наборів монет. Ефективний у випадках, коли набір монет відповідає *умові канонічного представлення*.

### Алгоритм динамічного програмування (DP)
Алгоритм динамічного програмування розбиває задачу на підзадачі, знаходячи мінімальну кількість монет для кожної проміжної суми, поки не буде досягнуто цільової суми.

- **Часова складність**: \(O(nt)\), де \(n\) — кількість номіналів, а \(t\) — цільова сума. Підхід гарантує оптимальне рішення, але його продуктивність падає для великих сум через значні вимоги до пам'яті та часу.
- **Продуктивність при великих сумах**: DP забезпечує оптимальні рішення для будь-якого набору монет, але може бути повільним для великих значень цільової суми.

### Висновок
- Використовуйте **жадібний алгоритм** для стандартних наборів монет, коли потрібне швидке й просте рішення.
- Використовуйте **динамічне програмування** для нестандартних наборів або великих сум, коли критично важливо знайти оптимальне рішення.
